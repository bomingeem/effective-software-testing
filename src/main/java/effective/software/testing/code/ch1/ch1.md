# 1장. 효율적이고 체계적인 소프트웨어 테스트

## 1.1 테스트를 하는 개발자와 하지 않는 개발자

- 소스 코드 참고

## 1.2 개발자를 위한 효율적인 소프트웨어 테스트

- 요구사항을 작은 부분으로 나누어 테스트 케이스를 도출해내는, 이른바 ‘**도메인 테스트**’ 기법을 사용
    - **구조적 테스트**(또는 코드 커버리지)를 통해 현재의 테스트 케이스가 충분한지 평가
    - 몇몇 테스트 케이스에 대해서는 **예시 기반 테스트**(테스트를 위해 한가지 data point를 고름)를 작성
    - 특이한 경우에 대해서는 **속성 기반 테스트** 사용
    - **계약**과 스스로 고안한 방법의 **사전**, **사후 조건**을 종종 살핌

### 1.2.1 개발 과정에서의 효율적인 테스트

1. 기능 개발은 개발자가 어떤 종류의 **요구사항**을 받는 것으로부터 시작하며 개발자는 **요구사항 분석** 후 코드 작성 시작
2. 기능 개발을 유도하기 위해 개발자는 짧은 **테스트 주도 개발(TDD)** 과정을 반복
3. 개발자는 결국 **여러 단위**(클래스나 메서드)를 만들게 되며 각 단위는 다른 **계약**을 가지고 있고 서로 어울려 전체 기능을 구성하게 된다. 개발자는 항상 **테스트 가능성**을 염두에 두고 설계
4. 첫 단계로 새로 만든 각 단위를 테스트한다. **도메인 테스트**, **경계 테스트**, **구조적 테스트** 기법 적용
5. 시스템에는 **대규모 테스트**(통합 테스트나 시스템 테스트)가 필요한 부분이 있다
6. 테스트 케이스를 만들고 나면 자동화된 **지능형 테스트** 도구를 써서 사람이 잘 도출하지 못하는 케이스를 찾아낸다. **테스트 케이스 생성**, **돌연변이 테스트**, **정적 분석**
7. 편안하게 배포!

### 1.2.2 반복 프로세스로서의 효율적 테스트

- 개발 흐름은 자유롭게 앞뒤로 왔다 갔다 하며 적용하려는 기법의 순서를 바꾸어보자. 실제로 자신에게 가장 적합하고 생산적인 방법을 찾아야 한다.

### 1.2.3 개발에 먼저 집중하고 나서 테스트하기

- 구현 중에는 모든 에너지를 비즈니스 규칙에 쏟고 원하는 동시에 나중에 유지 보수할 개발자들이 쉽게 이해하도록 하길 권장
- 코드 작성을 마치고 나면 테스트에 집중

### 1.2.4 ‘제대로 된 설계’에 관한 미신

- 소프트웨어 개발자들 사이에는 코드가 단순해지도록 설계하면 버그가 없을 것이라는 인식이 있다. 마치 버그가 없는 코드는 단순함에 있는 듯 말이다.
- 코드를 더 잘 설계했다고 해서 발생할 수 있는 모든 버그를 피할수는 없다.

### 1.2.5 테스트 비용

- 상용 버전에서 발생하는 버그의 비용은 종종 예방하는 비용보다 훨씬 더 크다
- 버그를 많이 만들어내는 팀은 개발자가 버그를 만들고 나서 고객이 버그를 발견하고 버그를 고치고 고객이 다시 다른 버그를 찾는 무한 루프에 시간을 많이 소모한다
- 연습이 관건이다. 테스트 케이스를 작성하는 데 익숙해지면 더 빨리 작성할 수 있다

### 1.2.6 효율적이면서 체계적이라는 것의 의미

- **효율적**이라는 말은 올바른 테스트를 작성하는 데 집중해야 함을 뜻한다
- **체계적**이라는 말은 어떤 코드 조각에 대해 어느 개발자라도 같은 테스트 스위트를 만들어낸다는 것을 의미한다

### 1.2.7 테스트 자동화의 역할

- 테스트 케이스를 **설계**하는 것과 **실행**하는 것을 명확히 구분하도록 하자

## 1.3 소프트웨어 테스트 원칙(테스트는 왜 이렇게 어려운가)

### 1.3.1 완벽한 테스트는 불가능하다

- 시스템에서 일어날 수 있는 모든 상황을 테스트하는 일은 자원이 무한정 있어도 불가능할 수 있다
- 개발자는 무엇을 테스트할지 선택해야 한다. **효율적인 테스트**가 필요하다고 강조하는 이유다.

### 1.3.2 테스트를 그만둘 때를 파악하기

- 테스트를 너무 적게 작성하면 의도한 대로 동작하지 않는 소프트웨어 시스템을 만들게 된다
- 반면 명확한 가정 없이 계속 테스트를 작성하는 것은 비효율적인 테스트가 될 수 있다
- 테스트를 ‘언제 그만둘지 결정’하는데 도움이 되는 적절함의 기준에 대해 논의한다

### 1.3.3 가변성이 중요하다(살충제 역설)

- 가능한 버그를 모두 찾기 위해 항상 사용할 수 있는 기법은 존재하지 않는다
- 단 하나의 기법만 사용하기로 결정한다면 그 기법으로 찾을 수 있는 모든 버그를 발견할 수는 있지만 그 이상은 찾을 수 없다
- 테스터는 소프트웨어에 남은 버그 수를 최소화하려면 또 다른 테스트 전략을 사용해야 한다

### 1.3.4 버그는 다른 곳에 비해 많이 발생하는 지점이 있다

- 테스트 케이스에 우선순위를 정할 때 버그가 균일하게 분포되어 있지 않다는 점에 유의하자
- ex) **결제** 모듈은 **마케팅** 모듈보다 훨씬 엄격한 테스트가 필요할 수 있다. 이러한 경향을 **결함 클러스터링**이라고 한다.

### 1.3.5 어떤 테스트를 하든지 결코 완벽하거나 충분하지 않다

- 단순히 테스트를 더 많이 해서 버그를 더 찾을 수 있지만, 테스트가 얼마나 대량으로 진행되든지 간에 소프트웨어 시스템에 버그가 100% 존재하지 않는다는 것을 보장할 수 없을 것이다.
- 테스트는 시스템이 우리가 기대하는 대로 동작하는지를 검증하는 케이스만을 보장할 뿐이다.
- ‘모든 것을 테스트할 수는 없다’라는 말을 받아들여야 한다.

### 1.3.6 맥락이 핵심이다

- 테스트 케이스를 도출할 때 맥락(context)이 중요한 역할을 한다

### 1.3.7 검증은 유효성 검사가 아니다

- 오류 없이 동작하지만 사용자에게 쓸모없는 소프트웨어 시스템은 좋은 시스템이 아니다.
- 소프트웨어 테스터가 __검증(Verification)__에만 몰두하고 __검사(Validation)__에 신경을 많이 쓰지 않을 때 이러한 **에러 부재의 오류**를 맞닥뜨린다.
- **검증**은 __시스템이 제대로 되어 있는가에 관한 것__이라면, **유효성 검사**는 __올바른 시스템을 가지는 방법에 관한 것__이다

## 1.4 테스트 피라미드와 집중해야 할 부분

![테스트피라미드](https://user-images.githubusercontent.com/47099798/232305718-45a2741d-a91d-4bf5-a52d-3e56e0540329.png)

- 실용적 테스트에 관해 이야기할 때 가장 먼저 결정해야 할 사항은 어느 **수준**으로 코드를 테스트해야 하는가다.
- 테스트 수준에 따라 **단위** 테스트, **통합** 테스트, **시스템** 테스트가 있다.

### 1.4.1 단위 테스트

- 단위를 격리해서 테스트하는 것을 **단위 테스트**라고 한다.
    - 장점: 빠르다, 다루기 쉽다, 작성하기 쉽다
    - 단점: 현실성이 떨어진다, 잡을 수 없는 종류의 버그가 존재한다
- 단위 테스트는 시스템에서 작업 단위를 호출하는 자동화된 코드 조각이다. 그리고 작업 단위는 한 메서드, 한 클래스 또는 함께 동작하는 여러 클래스에 이를 수 있고, 검증 가능한 단 하나의 논리적 목표를 달성한다.
- 단위 테스트는 외부 시스템에 의존하지 않는 (작은) 클래스 세트, 또는 완전히 제어하지 못하는 무언가를 테스트하는 것을 뜻한다.

### 1.4.2 통합 테스트

- 통합 테스트는 우리의 코드와 외부 요소 간의 통합을 테스트해야 할 때 사용하는 테스트 수준이다.
- 통합 테스트의 목적은 시스템의 여러 구성요소를 함께 테스트하는 것이며, 시스템 전체를 테스트하는 대신 구성요소들의 상호작용에 초점을 맞춘다.
- ex) 서로 제대로 통신하고 있는지, A 구성요소가 X 메시지를 B 구성요소로 보내면 어떻게 되는지, 그것들이 여전히 올바르게 동작하는지를 테스트한다.

### 1.4.3 시스템 테스트

- 시스템의 작은 부분을 격리해서 테스트하는 대신 시스템 전체를 테스트할 때 우리는 시스템 테스트를 수행하게 된다.
- 시스템 테스트의 명백한 이점은 ‘**테스트가 현실적**’이라는 것이다.
- 단점: 느리다, 작성하기 힘들다, 불안정한 경향이 있다

### 1.4.4 각 테스트 수준을 언제 사용해야 할까?

- 서로 다른 테스트 수준과 그 이점을 명확히 이해하고 나면, 우리는 어디에 더 노력을 들여야 할지, 그리고 어떤 구성요소는 어떤 테스트의 대상으로 할지 결정해야 한다.
- 잘못된 결정은 시스템의 품질에 상당한 영향을 미칠 수 있으며, 많은 자원을 소모하고 버그를 충분히 찾지 못할수도 있다. 여기서 가장 좋은 대답은 ‘**상황에 따라 다르다**’는 것이다.
    - 수동 테스트: 탐색적 테스트
    - 시스템 테스트: 애플리케이션의 주요하고 위험한 실행 흐름에 대한 테스트
    - 통합 테스트: 외부 서비스와의 복잡한 통합
    - 단위 테스트: 모든 비즈니스 규칙은 여기서 테스트되어야 한다

### 1.4.5 단위 테스트를 선호하는 이유

- 작성하기 쉽고, 빠르며, 제품 코드와 엮어서 만들 수 있다.
- 또한 소프트웨어 개발자가 작업하는 방식과 잘 들어맞는다고 믿는다.
- 작은 단위에 대해 효율적이고 엄격하게 테스트하는 일은 더 큰 기능을 테스트하는 것보다 훨씬 쉽다.
- 다른 수준에서 모든 기능을 다시 테스트할 필요는 없다. 통합 도중 문제 발생 소지가 있을 것 같은 코드의 특정 부분을 통합 테스트나 시스템 테스트를 사용하여 테스트한다.

### 1.4.6 각 수준에서 무엇을 테스트해야 할까?

- 소프트웨어 시스템의 알고리즘이나 단일 비즈니스 로직과 관련된 단위에 대해서는 단위 테스트를 사용한다.
- 테스트 대상 구성요소가 외부 구성요소와 상호작용할 때마다 통합 테스트를 사용한다.
- 시스템 테스트는 매우 비용이 많이 든다(작성하기 어렵고 실행 속도가 느리다)

### 1.4.7 테스트 피라미드에 동의하지 않는다면

- 그들은 **테스트 트로피**를 해야 한다고 주장한다. 단위 테스트는 좀 더 얇고, 중간의 통합 테스트는 좀 더 크며, 상단의 시스템 테스트도 더 얇은 형태를 띤다.
- 마이크로 서비스 테스트 문제를 해결하기 위해 각 마이크로 서비스에 대해 __수많은 단위 테스트를 작성__해서 __모든 것이 올바르게 동작하는지 확인__하고, 계약 설계에 많은 노력을 기울여 마이크로 서비스가 __사전, 사후 조건을 명확히 갖도록 할 것__이다. 그런 다음 __통합 테스트를 많이 수행__해서 시스템 간 통신은 기대했던 대로 이루어지는지, 분산 시스템에서 일반적으로 발생하는 변동으로 인해 __시스템이 망가지지 않았는지 확인__할 것이다.
- 이 시나리오에서는 테스트를 많이 수행해서 얻는 이익이 비용보다 크다.
- **테스트 범위보다 크기가 중요하다**
    - **작은 테스트**는 단일 프로세스에서 실행할 수 있는 테스트이다.
    - **중간 크기 테스트**는 여러 프로세스에 걸쳐 실행될 수 있고, 스레드를 사용할 수 있으며 로컬 호스트에 외부 호출을 할 수 있다.
    - 큰 테스트는 로컬 호스트라는 제한을 없애서 다른 컴퓨터를 호출할 수 있다. ex) 구글에서는 큰 테스트를 end-to-end 테스트에 사용
- 결국 시스템의 각 부분이 무엇이든 간에 목표는 __테스트 효과를 극대화__하는 것이다.
